// Import necessary types and interfaces
import {
  OCPPTransactionEventEnumType,
  OCPPTriggerReasonEnumType,
  OCPPTransactionType,
  OCPPIdTokenType,
  OCPPEVSEType,
  OCPPMeterValueType,
  OCPPChargingStateEnumType,
  OCPPReasonEnumType,
  OCPPTransactionEventRequestExtended201,
  OCPPTransactionEventResponse201,
  OCPPIdTokenInfoType,
  OCPPMessageFormatEnumType,
  OCPPAuthorizationStatusEnumType
} from './OCPPTypes';

// Define the class for transaction event request
class OCPPTransactionEventRequestExtended201 {
  eventType: OCPPTransactionEventEnumType;
  timestamp: string;
  triggerReason: OCPPTriggerReasonEnumType;
  seqNo: number;
  offline?: number;
  numberOfPhasesUsed?: number;
  cableMaxCurrent?: number;
  reservationId?: number;
  transactionInfo: OCPPTransactionType;
  idToken?: OCPPIdTokenType;
  evse?: OCPPEVSEType;
  meterValue?: OCPPMeterValueType[];
  chargeBoxID: string;
  tagID: string;
  timezone: string;
  userID: string;
  siteAreaID: string;
  siteID: string;
  companyID: string;

  constructor(data: any) {
    this.eventType = data.eventType;
    this.timestamp = data.timestamp;
    this.triggerReason = data.triggerReason;
    this.seqNo = data.seqNo;
    this.offline = data.offline;
    this.numberOfPhasesUsed = data.numberOfPhasesUsed;
    this.cableMaxCurrent = data.cableMaxCurrent;
    this.reservationId = data.reservationId;
    this.transactionInfo = data.transactionInfo;
    this.idToken = data.idToken;
    this.evse = data.evse;
    this.meterValue = data.meterValue;
    this.chargeBoxID = data.chargeBoxID;
    this.tagID = data.tagID;
    this.timezone = data.timezone;
    this.userID = data.userID;
    this.siteAreaID = data.siteAreaID;
    this.siteID = data.siteID;
    this.companyID = data.companyID;
  }
}

// Define the function to handle meter values
async function handleMeterValues(headers: any, meterValues: any): Promise<void> {
  try {
    const { chargingStation, tenant } = headers;
    await validateMeterValues(tenant.id, chargingStation, meterValues);
    const normalizedMeterValues = normalizeMeterValues(chargingStation, meterValues);
    filterMeterValuesOnSpecificChargingStations(tenant, chargingStation, normalizedMeterValues);

    if (isEmptyArray(normalizedMeterValues.values)) {
      logDebug({
        ...getChargingStationProperties(chargingStation),
        tenantID: tenant.id,
        module: 'MODULE_NAME',
        method: 'handleMeterValues',
        action: 'OCPP_METER_VALUES',
        message: 'No relevant Meter Values to save',
        detailedMessages: { meterValues }
      });
      return;
    }

    const transaction = await getTransactionFromMeterValues(tenant, chargingStation, headers, meterValues);
    await saveMeterValues(tenant, normalizedMeterValues);
    updateTransactionWithMeterValues(chargingStation, transaction, normalizedMeterValues.values);
    const consumptions = await createConsumptionsFromMeterValues(tenant, chargingStation, transaction, normalizedMeterValues.values);
    await processTransactionCar(tenant, transaction, chargingStation, consumptions[consumptions.length - 1], null, 'UPDATE');

    for (const consumption of consumptions) {
      updateTransactionWithConsumption(chargingStation, transaction, consumption);
      if (consumption.toPrice) {
        await processUpdateTransaction(tenant, transaction, chargingStation, consumption, transaction.user);
        await processUpdateTransaction(tenant, transaction, transaction.user);
        await saveConsumption(tenant, consumption);
      }
    }

    if (!transaction.phasesUsed && checkIfPhasesProvidedInTransactionInProgress(transaction) && transaction.numberOfMeterValues >= 1) {
      transaction.phasesUsed = getUsedPhasesInTransactionInProgress(chargingStation, transaction);
    }

    await processUpdateTransaction(tenant, transaction, chargingStation, chargingStation.siteArea, transaction.user, 'OCPP_METER_VALUES');
    await saveTransaction(tenant, transaction);
    await updateChargingStationConnectorRuntimeDataWithTransaction(tenant, chargingStation, transaction);
    await saveChargingStation(tenant, chargingStation);
    await checkNotificationEndOfCharge(tenant, chargingStation, transaction);

    if (transaction.numberOfMeterValues === 1 && transaction.phasesUsed) {
      await triggerSmartCharging(tenant, chargingStation.siteArea);
    }

    logInfo({
      ...getChargingStationProperties(chargingStation),
      tenantID: tenant.id,
      action: 'OCPP_METER_VALUES',
      user: transaction.userID,
      module: 'MODULE_NAME',
      method: 'handleMeterValues',
      message: `${buildConnectorInfo(meterValues.connectorId, meterValues.transactionId)} MeterValue have been saved`,
      detailedMessages: { normalizedMeterValues }
    });
  } catch (error) {
    addChargingStationToException(error, headers.chargeBoxIdentity);
    logActionExceptionMessage(headers.tenantID, 'OCPP_METER_VALUES', error, { meterValues });
  }
}

// Define the consolidated function
async function TransactionEventResponse(headers: any, data: any): Promise<OCPPTransactionEventResponse201> {
  const transactionEventRequest = new OCPPTransactionEventRequestExtended201(data);
  await handleMeterValues(headers, transactionEventRequest.meterValue);

  // Process the transaction event based on the event type
  let response: OCPPTransactionEventResponse201 = {
    totalCost: 0,
    chargingPriority: 0,
    idTokenInfo: undefined,
    updatedPersonalMessage: ''
  };

  switch (transactionEventRequest.eventType) {
    case OCPPTransactionEventEnumType.STARTED:
      response = handleTransactionStarted(transactionEventRequest);
      break;
    case OCPPTransactionEventEnumType.UPDATED:
      response = handleTransactionUpdated(transactionEventRequest);
      break;
    case OCPPTransactionEventEnumType.ENDED:
      response = handleTransactionEnded(transactionEventRequest);
      break;
    default:
      throw new Error('Unsupported event type');
  }

  return response;
}

// Handle transaction started event
function handleTransactionStarted(request: OCPPTransactionEventRequestExtended201): OCPPTransactionEventResponse201 {
  const idTokenInfo: OCPPIdTokenInfoType = generateIdTokenInfo(request, 'Transaction Started');
  return {
    totalCost: 0,
    chargingPriority: 1,
    idTokenInfo: idTokenInfo,
    updatedPersonalMessage: 'Transaction has started successfully'
  };
}

// Handle transaction updated event
function handleTransactionUpdated(request: OCPPTransactionEventRequestExtended201): OCPPTransactionEventResponse201 {
  const idTokenInfo: OCPPIdTokenInfoType = generateIdTokenInfo(request, 'Transaction Updated');
  return {
    totalCost: calculateTotalCost(request),
    chargingPriority: 1,
    idTokenInfo: idTokenInfo,
    updatedPersonalMessage: 'Transaction has been updated successfully'
  };
}

// Handle transaction ended event
function handleTransactionEnded(request: OCPPTransactionEventRequestExtended201): OCPPTransactionEventResponse201 {
  const idTokenInfo: OCPPIdTokenInfoType = generateIdTokenInfo(request, 'Transaction Ended');
  return {
    totalCost: calculateTotalCost(request),
    chargingPriority: 1,
    idTokenInfo: idTokenInfo,
    updatedPersonalMessage: 'Transaction has ended successfully'
  };
}

// Function to generate IdTokenInfo
function generateIdTokenInfo(request: OCPPTransactionEventRequestExtended201, message: string): OCPPIdTokenInfoType {
  return {
    status: OCPPAuthorizationStatusEnumType.ACCEPTED,
    cacheExpiryDateTime: new Date(),
    chargingPriority: 1,
    language1: 'en',
    evseId: [request.evse?.evseId || 1],
    language2: 'en',
    groupIdToken: request.idToken,
    personalMessage: {
      content: message,
      language: 'en',
      format: OCPPMessageFormatEnumType.UTF8
    }
  };
}

// Function to dynamically calculate total cost
function calculateTotalCost(request: OCPPTransactionEventRequestExtended201): number {
  const ratePerUnit = 0.15; // Example rate per unit of energy
  const timeSpentCharging = request.transactionInfo?.timeSpentCharging || 0;
  return timeSpentCharging * ratePerUnit;
}

// Helper functions (placeholders for actual implementations)
function validateMeterValues(tenantId: string, chargingStation: any, meterValues: any): Promise<void> { /* ... */ }
function normalizeMeterValues(chargingStation: any, meterValues: any): any { /* ... */ }
function filterMeterValuesOnSpecificChargingStations(tenant: any, chargingStation: any, normalizedMeterValues: any): void { /* ... */ }
function isEmptyArray(array: any[]): boolean { /* ... */ }
function logDebug(log: any): void { /* ... */ }
function getTransactionFromMeterValues(tenant: any, chargingStation: any, headers: any, meterValues: any): Promise<any> { /* ... */ }
function saveMeterValues(tenant: any, normalizedMeterValues: any): Promise<void> { /* ... */ }
function updateTransactionWithMeterValues(chargingStation: any, transaction: any, values: any): void { /* ... */ }
function createConsumptionsFromMeterValues(tenant: any, chargingStation: any, transaction: any, values: any): Promise<any[]> { /* ... */ }
function processTransactionCar(tenant: any, transaction: any, chargingStation: any, consumption: any, arg1: any, action: string): Promise<void> { /* ... */ }
function updateTransactionWithConsumption(chargingStation: any, transaction: any, consumption: any): void { /* ... */ }
function processUpdateTransaction(tenant: any, transaction: any, chargingStation: any, consumption: any, user: any): Promise<void> { /* ... */ }
function saveConsumption(tenant: any, consumption: any): Promise<void> { /* ... */ }
function checkIfPhasesProvidedInTransactionInProgress(transaction: any): boolean { /* ... */ }
function getUsedPhasesInTransactionInProgress(chargingStation: any, transaction: any): any { /* ... */ }
function processUpdateTransaction(tenant: any, transaction: any, chargingStation: any, siteArea: any, user: any, action: string): Promise<void> { /* ... */ }
function saveTransaction(tenant: any, transaction: any): Promise<void> { /* ... */ }
function updateChargingStationConnectorRuntimeDataWithTransaction(tenant: any, chargingStation: any, transaction: any): Promise<void> { /* ... */ }
function saveChargingStation(tenant: any, chargingStation: any): Promise<void> { /* ... */ }
function checkNotificationEndOfCharge(tenant: any, chargingStation: any, transaction: any): Promise<void> { /* ... */ }
function triggerSmartCharging(tenant: any, siteArea: any): Promise<void> { /* ... */ }
function logInfo(log: any): void { /* ... */ }
function addChargingStationToException(error: any, chargeBoxIdentity: any): void { /* ... */ }
function logActionExceptionMessage(tenantID: any, action: any, error: any, details: any): void { /* ... */ }
function getChargingStationProperties(chargingStation: any): any { /* ... */ }
function buildConnectorInfo(connectorId: any, transactionId: any): string { /* ... */ }
